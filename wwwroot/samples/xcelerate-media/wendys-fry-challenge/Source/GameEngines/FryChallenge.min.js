// Hotspot data for the Fry holding bins.
var FryChallenge;
(function (FryChallenge) {
    var Fries = (function () {
        function Fries() {
        }
        Fries.Configure = function (left) {
            this.left = left;
        };
        Fries.Get = function (index) {
            var r = new Phaser.Rectangle((this.fries[index].x * this.left.scale.x), (this.fries[index].y * this.left.scale.y) + this.left.top, this.fries[index].width, this.fries[index].height);
            r.scale(this.left.scale.x, this.left.scale.y);
            return r;
        };
        Fries.Test = function (index, point) {
            return this.Get(index).contains(point.x, point.y);
        };
        Fries.fries = [
            new Phaser.Rectangle(308, 423, 75, 125),
            new Phaser.Rectangle(384, 453, 65, 125)
        ];
        return Fries;
    }());
    FryChallenge.Fries = Fries;
})(FryChallenge || (FryChallenge = {}));

///<reference path="../../node_modules/phaser/typescript/phaser.d.ts" />
///<reference path="../../_Published/Source/XM/Helpers.js" />
///<reference path="../../_Published/Source/XM/LMS/LMSBase.js" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var FryChallenge;
(function (FryChallenge) {
    var FryGame = (function (_super) {
        __extends(FryGame, _super);
        function FryGame() {
            // Fix iOS iframe sizing issue.
            $(window).resize(function () {
                if (IsInMobileSafari()) {
                    document.body.style.width = parent['contentWidth'];
                    document.body.style.height = parent['contentHeight'];
                }
            });
            $(document).on('touchmove', false);
            _super.call(this, "100%", "100%", Phaser.AUTO, 'container');
            this.state.add('Boot', FryChallenge.Boot, false);
            this.state.add('Preload', FryChallenge.Preload, false);
            this.state.add('Main', FryChallenge.Main, false);
            this.state.start('Boot');
        }
        FryGame.instance = function () {
            return window['game'];
        };
        FryGame.PlaySound = function (key) {
            return window['sounds'][key].loop(false).play();
        };
        FryGame.StopSound = function (key, id) {
            window['sounds'][key].stop(id);
        };
        FryGame.LoopSound = function (key) {
            return window['sounds'][key].loop(true).play();
        };
        FryGame.Correct = function () {
            $('#correct')
                .show()
                .css({ opacity: 1 })
                .animate({ opacity: 0 }, 500, 'linear', function () {
                $(this).hide();
            });
        };
        FryGame.Wrong = function () {
            $('#wrong')
                .show()
                .css({ opacity: 1 })
                .animate({ opacity: 0 }, 500, 'linear', function () {
                $(this).hide();
            });
        };
        return FryGame;
    }(Phaser.Game));
    FryChallenge.FryGame = FryGame;
})(FryChallenge || (FryChallenge = {}));

// Hotspot data for the basket handles.
var FryChallenge;
(function (FryChallenge) {
    var Handles = (function () {
        function Handles() {
        }
        Handles.Configure = function (world, right) {
            this.world = world;
            this.right = right;
        };
        Handles.Get = function (index) {
            var r = new Phaser.Rectangle((this.handles[index].x * this.right.scale.x) + this.world.centerX, (this.handles[index].y * this.right.scale.y) + this.right.top, this.handles[index].width, this.handles[index].height);
            r.scale(this.right.scale.x, this.right.scale.y);
            return r;
        };
        Handles.Test = function (index, point) {
            return this.Get(index).contains(point.x, point.y);
        };
        Handles.handles = [
            new Phaser.Rectangle(25, 470, 55, 100),
            new Phaser.Rectangle(80, 470, 60, 100),
            new Phaser.Rectangle(180, 470, 60, 100),
            new Phaser.Rectangle(240, 470, 80, 100),
            new Phaser.Rectangle(355, 470, 85, 100)
        ];
        return Handles;
    }());
    FryChallenge.Handles = Handles;
})(FryChallenge || (FryChallenge = {}));

var FryChallenge;
(function (FryChallenge) {
    var InputEvent = (function () {
        function InputEvent() {
        }
        InputEvent.MouseDown = ('PointerEvent' in window ? 'pointerdown' : ('MSPointerEvent' in window ? 'MSPointerDown' : 'mousedown touchstart'));
        InputEvent.MouseMove = ('PointerEvent' in window ? 'pointermove' : ('MSPointerEvent' in window ? 'MSPointerMove' : 'mousemove touchmove'));
        InputEvent.MouseUp = ('PointerEvent' in window ? 'pointerup' : ('MSPointerEvent' in window ? 'MSPointerUp' : 'mouseup touchend'));
        InputEvent.Click = 'click touchstart';
        return InputEvent;
    }());
    FryChallenge.InputEvent = InputEvent;
})(FryChallenge || (FryChallenge = {}));

// Hotspot data for the nugget holding bins.
var FryChallenge;
(function (FryChallenge) {
    var Nuggets = (function () {
        function Nuggets() {
        }
        Nuggets.Configure = function (left) {
            this.left = left;
        };
        Nuggets.Get = function (index) {
            var r = new Phaser.Rectangle((this.nuggets[index].x * this.left.scale.x), (this.nuggets[index].y * this.left.scale.y) + this.left.top, this.nuggets[index].width, this.nuggets[index].height);
            r.scale(this.left.scale.x, this.left.scale.y);
            return r;
        };
        Nuggets.Test = function (index, point) {
            return this.Get(index).contains(point.x, point.y);
        };
        Nuggets.nuggets = [
            new Phaser.Rectangle(140, 480, 95, 85),
            new Phaser.Rectangle(175, 418, 105, 63)
        ];
        return Nuggets;
    }());
    FryChallenge.Nuggets = Nuggets;
})(FryChallenge || (FryChallenge = {}));

// Hotspot data for the oil slots.
var FryChallenge;
(function (FryChallenge) {
    var Oil = (function () {
        function Oil() {
        }
        Oil.Configure = function (world, right) {
            this.world = world;
            this.right = right;
        };
        Oil.Get = function (index) {
            var r = new Phaser.Rectangle((this.oil[index].x * this.right.scale.x) + this.world.centerX, (this.oil[index].y * this.right.scale.y) + this.right.top, this.oil[index].width, this.oil[index].height);
            r.scale(this.right.scale.x, this.right.scale.y);
            return r;
        };
        Oil.Test = function (index, point) {
            return this.Get(index).contains(point.x, point.y);
        };
        Oil.oil = [
            new Phaser.Rectangle(25, 395, 55, 160),
            new Phaser.Rectangle(85, 395, 55, 160),
            new Phaser.Rectangle(175, 395, 55, 160),
            new Phaser.Rectangle(230, 395, 80, 160),
            new Phaser.Rectangle(320, 395, 85, 160)
        ];
        return Oil;
    }());
    FryChallenge.Oil = Oil;
})(FryChallenge || (FryChallenge = {}));

var FryChallenge;
(function (FryChallenge) {
    var Operation = (function () {
        function Operation() {
            this.value = '';
            this.showNext = false;
            this.wait = false;
            this.indicator = false;
        }
        return Operation;
    }());
    FryChallenge.Operation = Operation;
})(FryChallenge || (FryChallenge = {}));

var FryChallenge;
(function (FryChallenge) {
    var Controls;
    (function (Controls) {
        var Quiz = (function () {
            function Quiz() {
                this.element = $('#question-container').get(0);
            }
            Quiz.prototype.Show = function (question) {
                var _this = this;
                this.question = question;
                var qHtml = $('<div id="question">');
                qHtml.append('<div id="question-text">' + question.question + '</div>');
                var aHtml = $('<ul id="answers">');
                for (var i = 0; i < question.answers.length; i++) {
                    aHtml.append('<li class="answer ' + (question.correct == i ? 'right' : 'wrong') + '">' + question.answers[i] + '</li>');
                    aHtml.children().last().on('click', function (e) { return _this.OnSelectAnswer(e); });
                }
                qHtml.append(aHtml).append('<div id="remediation">');
                $(this.element).html('').append(qHtml).show();
            };
            Quiz.prototype.Hide = function () {
                $(this.element).hide();
            };
            Quiz.prototype.OnSelectAnswer = function (e) {
                var $selection = $(e.currentTarget);
                $selection.addClass('selected');
                if ($selection.hasClass('right')) {
                    $selection.parent().addClass('right');
                    FryChallenge.FryGame.PlaySound('good');
                    FryChallenge.FryGame.Correct();
                }
                else {
                    $selection.parent().addClass('wrong');
                    FryChallenge.FryGame.PlaySound('bad');
                    FryChallenge.FryGame.Wrong();
                }
                // For the quiz, we set the number of attempts to the index of the answer to get the correct point value.
                FryChallenge.FryGame.instance().state.getCurrentState().attempts = $selection.index();
                $('#remediation').html(this.question.remediation[$selection.index()]);
                FryChallenge.FryGame.instance().state.getCurrentState().PlayVoiceLine(this.question.remediationAudio[$selection.index()]);
                $('.answer').off('click');
                FryChallenge.FryGame.instance().state.getCurrentState().EvaluateNext();
            };
            return Quiz;
        }());
        Controls.Quiz = Quiz;
    })(Controls = FryChallenge.Controls || (FryChallenge.Controls = {}));
})(FryChallenge || (FryChallenge = {}));

var FryChallenge;
(function (FryChallenge) {
    var Timer = (function () {
        function Timer(element) {
            this.element = element;
        }
        Timer.prototype.Activate = function (startTime, speed, minTime, awaitClick, awaitFinish) {
            if (speed === void 0) { speed = 1000; }
            if (minTime === void 0) { minTime = 0; }
            if (awaitClick === void 0) { awaitClick = false; }
            if (awaitFinish === void 0) { awaitFinish = false; }
            // Clear any previous timer interval.
            if (this.interval)
                clearInterval(this.interval);
            // Set new defaults       
            if (startTime == -1)
                this.startTime = this.time;
            else
                this.time = this.startTime = startTime;
            this.speed = speed;
            this.minTime = minTime;
            this.awaitingFinish = awaitFinish;
            this.awaitingClick = awaitClick;
            // Await user action to start.
            if (awaitClick) {
                var wrongCallback = function () {
                    FryChallenge.FryGame.PlaySound('bad');
                    FryChallenge.FryGame.Wrong();
                    // Increment the number of attempts it took to get it right for scoring:
                    FryChallenge.FryGame.instance().state.getCurrentState().attempts++;
                };
                $(this.element).parent().one('click', function () {
                    $('#time-bar .left > div, #time-bar .right > div').not($(this.element).parent()).off('click', wrongCallback);
                    this.Start();
                    FryChallenge.FryGame.PlaySound('good');
                    FryChallenge.FryGame.Correct();
                }.bind(this));
                $('#time-bar .left > div, #time-bar .right > div').not($(this.element).parent()).on('click', wrongCallback);
            }
            else
                this.Start();
        };
        Timer.prototype.Start = function () {
            // Display start time and begin the countdown.
            $(this.element).text(this.FormatTime());
            this.interval = setInterval(this.Tick.bind(this), this.speed);
            // Tell the game that we can move on.
            if (this.awaitingClick)
                FryChallenge.FryGame.instance().state.getCurrentState().EvaluateNext();
        };
        Timer.prototype.Reset = function (auto) {
            if (auto === void 0) { auto = false; }
            var self = this;
            // Clear any previous timer interval.
            if (this.interval)
                clearInterval(this.interval);
            if (auto) {
                $(this.element).text('--:--');
                return;
            }
            // Play the alarm sound and make the alarm blink:
            this.alarmSound = FryChallenge.FryGame.LoopSound('alarm');
            $(this.element).addClass('blink');
            var wrongCallback = function () {
                FryChallenge.FryGame.PlaySound('bad');
                FryChallenge.FryGame.Wrong();
                // Increment the number of attempts it took to get it right for scoring:
                FryChallenge.FryGame.instance().state.getCurrentState().attempts++;
            };
            // Reset the timer and move on.
            $(this.element).parent().one('click', function () {
                $('#time-bar .left > div, #time-bar .right > div').not($(self.element).parent()).off('click', wrongCallback);
                window['sounds']['alarm'].stop(self.alarmSound);
                FryChallenge.FryGame.PlaySound('good');
                FryChallenge.FryGame.Correct();
                $(self.element).removeClass('blink');
                $(this).find('.time').text('--:--');
                FryChallenge.FryGame.instance().state.getCurrentState().EvaluateNext();
            });
            $('#time-bar .left > div, #time-bar .right > div').not($(this.element).parent()).on('click', wrongCallback);
        };
        Timer.prototype.Tick = function () {
            this.time = Math.max(this.time - 1, this.minTime);
            $(this.element).text(this.FormatTime());
            // Sometimes we need to stall the timer so it doesn't finish early if the user is going slow.            
            if (this.time <= this.minTime) {
                clearInterval(this.interval);
                if (this.awaitingFinish)
                    FryChallenge.FryGame.instance().state.getCurrentState().EvaluateNext();
            }
        };
        Timer.prototype.FormatTime = function () {
            return (this.time / 60 > 9 ? '' : '0') + Math.max(Math.floor(this.time / 60), 0) + ':' + (this.time % 60 < 10 ? '0' : '') + Math.max(this.time % 60, 0);
        };
        return Timer;
    }());
    FryChallenge.Timer = Timer;
})(FryChallenge || (FryChallenge = {}));

/// <reference path="../../../typings/globals/jquery/index.d.ts" />
var FryChallenge;
(function (FryChallenge) {
    var Timers = (function () {
        function Timers() {
            var _this = this;
            this.nuggets = new Array();
            this.fries = new Array();
            this.oil = new Array();
            $('#time-bar .left > :first-child .time').each(function (i, e) { return _this.nuggets.push(new FryChallenge.Timer(e)); });
            $('#time-bar .left > :nth-child(3) .time, #time-bar .left > :last-child .time').each(function (i, e) { return _this.fries.push(new FryChallenge.Timer(e)); });
            $('#time-bar .right > * .time').each(function (i, e) { return _this.oil.push(new FryChallenge.Timer(e)); });
        }
        Timers.prototype.Activate = function (zone, index, args) {
            if (index === void 0) { index = 0; }
            var time = args.time == undefined ? -1 : args.time;
            var minTime = args.minTime == undefined ? -1 : args.minTime;
            this[zone][index].Activate(time, args.speed, minTime, args.awaitClick || false, args.awaitFinish || false);
        };
        Timers.prototype.Reset = function (zone, index, auto) {
            if (index === void 0) { index = 0; }
            if (auto === void 0) { auto = false; }
            this[zone][index].Reset(auto);
        };
        return Timers;
    }());
    FryChallenge.Timers = Timers;
})(FryChallenge || (FryChallenge = {}));

/// <reference path="../../../typings/globals/jquery/index.d.ts" />
var FryChallenge;
(function (FryChallenge) {
    var Controls;
    (function (Controls) {
        var ToolTray = (function () {
            function ToolTray() {
                this.draggableCorrect = false;
                this.element = $('#tool-tray').get(0);
                // Add the tool tray element below the container.
                $('#container').after(this.element);
                $(document.body).on(FryChallenge.InputEvent.MouseMove, this.OnMouseMove.bind(this));
                $(document.body).on(FryChallenge.InputEvent.MouseUp, this.OnMouseUp.bind(this));
                $(document.body).on('mouseleave', this.OnMouseLeave.bind(this));
                // Create a pulsing dot indicator
                this.indicator = document.createElement('div');
                this.indicator.className = 'pulse';
            }
            ToolTray.prototype.Show = function (tools, correct, target, indicator) {
                this.target = target;
                // Optionally show a pulsing indicator at the center of the target.
                if (indicator) {
                    $(this.indicator).css({
                        left: this.target.zone.Get(target.index).centerX,
                        top: this.target.zone.Get(target.index).centerY
                    });
                    $(document.body).append(this.indicator);
                }
                // If we've got new tools to render, populate the tray.
                if (tools) {
                    $(this.element).html('');
                    for (var i in tools) {
                        $(this.element).append(this.CreateTool(tools[i], tools[i] == correct));
                    }
                }
                //$(this.element).animate({ 'bottom': 0 }, 200);
            };
            ToolTray.prototype.ShowClick = function (tools, correct) {
                // If we've got new tools to render, populate the tray.
                if (tools) {
                    $(this.element).html('');
                    for (var i in tools) {
                        $(this.element).append(this.CreateTool(tools[i], tools[i] == correct, true));
                    }
                }
            };
            ToolTray.prototype.Hide = function () {
                //$(this.element).animate({ 'bottom': '-100px' }, 200);
            };
            ToolTray.prototype.Resize = function () {
                try {
                    $(this.indicator).css({
                        left: this.target.zone.Get(this.target.index).centerX,
                        top: this.target.zone.Get(this.target.index).centerY
                    });
                }
                catch (err) {
                }
            };
            ToolTray.prototype.CreateTool = function (tool, correct, click) {
                if (click === void 0) { click = false; }
                var self = this;
                var toolElement = document.createElement('div');
                toolElement.className = 'tool';
                $(toolElement).append('<div class="hover-button"><img src="../../Assets/Images/Game/tool-container.png" /><img src="../../Assets/Images/Game/tool-container-over.png" class="hover" /></div>' +
                    '<img draggable src="../../Assets/Images/Game/tray_' + tool + '.png" />');
                // Create a clone of the tool image to drag around.
                if (click) {
                    if (correct) {
                        $(toolElement).one('click', function (e) {
                            FryChallenge.FryGame.PlaySound('good');
                            FryChallenge.FryGame.Correct();
                            $(self.element).find('.tool').off('click');
                            FryChallenge.FryGame.instance().state.getCurrentState().EvaluateNext();
                        });
                    }
                    else {
                        $(toolElement).on('click', function (e) {
                            FryChallenge.FryGame.PlaySound('bad');
                            FryChallenge.FryGame.Wrong();
                            // Increment the number of attempts it took to get it right for scoring:
                            FryChallenge.FryGame.instance().state.getCurrentState().attempts++;
                        });
                    }
                }
                else {
                    $(toolElement).on(FryChallenge.InputEvent.MouseDown, function (e) {
                        self.draggableCorrect = correct;
                        self.draggableClone = $(this).children().last().clone()[0];
                        $(self.draggableClone).css({
                            position: 'absolute',
                            left: -10000,
                            top: -10000,
                            zIndex: 10000
                        });
                        $(self.draggableClone).appendTo(document.body);
                    });
                }
                return toolElement;
            };
            ToolTray.prototype.OnMouseMove = function (e) {
                if (this.draggableClone == undefined)
                    return;
                var evt = e;
                if (e.type == 'touchmove')
                    evt = e.originalEvent.touches[0];
                else if (e.type == 'MSPointerMove')
                    evt = e.originalEvent;
                // Keep the draggables inside the container because they cause iOS to inflate the iframe width when they go off the right or bottom.
                var leftPosition = Math.min(evt.clientX - $(this.draggableClone).width() / 2, $('body').width() - $(this.draggableClone).width());
                var topPosition = Math.min(evt.clientY - $(this.draggableClone).height() / 2, $('body').height() - $(this.draggableClone).height());
                $(this.draggableClone).css({
                    left: leftPosition,
                    top: topPosition
                });
                e.preventDefault();
            };
            ToolTray.prototype.OnMouseUp = function (e) {
                if (this.draggableClone == undefined)
                    return;
                var evt = e;
                if (e.type == 'touchend')
                    evt = e.originalEvent.changedTouches[0];
                else if (e.type == 'MSPointerUp')
                    evt = e.originalEvent;
                $(this.draggableClone).remove();
                this.draggableClone = undefined;
                if (this.draggableCorrect && this.target.zone.Test(this.target.index, new Phaser.Point(evt.clientX, evt.clientY))) {
                    FryChallenge.FryGame.PlaySound('good');
                    FryChallenge.FryGame.Correct();
                    $(this.indicator).remove();
                    $(this.element).find('.tool').off(FryChallenge.InputEvent.MouseDown);
                    FryChallenge.FryGame.instance().state.getCurrentState().EvaluateNext();
                }
                else {
                    FryChallenge.FryGame.PlaySound('bad');
                    FryChallenge.FryGame.Wrong();
                    // Increment the number of attempts it took to get it right for scoring:
                    FryChallenge.FryGame.instance().state.getCurrentState().attempts++;
                }
            };
            ToolTray.prototype.OnMouseLeave = function (e) {
                if (this.draggableClone == undefined)
                    return;
                $(this.draggableClone).remove();
                this.draggableClone = undefined;
            };
            return ToolTray;
        }());
        Controls.ToolTray = ToolTray;
    })(Controls = FryChallenge.Controls || (FryChallenge.Controls = {}));
})(FryChallenge || (FryChallenge = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var FryChallenge;
(function (FryChallenge) {
    var Boot = (function (_super) {
        __extends(Boot, _super);
        function Boot() {
            _super.apply(this, arguments);
        }
        Boot.prototype.create = function () {
            // Configure game engine settings:
            this.input.maxPointers = 2;
            this.game.stage.disableVisibilityChange = true;
            // Configure scaling:
            this.game.scale.scaleMode = Phaser.ScaleManager.RESIZE;
            // Start loading the game.            
            this.game.state.start('Preload', true, false);
        };
        return Boot;
    }(Phaser.State));
    FryChallenge.Boot = Boot;
})(FryChallenge || (FryChallenge = {}));

///<reference path="../../../_Published/Source/XM/Helpers.js" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var FryChallenge;
(function (FryChallenge) {
    var Main = (function (_super) {
        __extends(Main, _super);
        function Main() {
            _super.apply(this, arguments);
            this.currentOperation = 0;
            this.helpTime = 10000;
            this.leftFrame = 1;
            this.rightFrame = 1;
            this.firstAudio = true;
            this.attempts = 0;
            this.score = 0;
        }
        Main.prototype.create = function () {
            this.script = window['script'];
            this.game.input.enabled = false;
            // Create game environment sprites:
            this.left = this.add.sprite(0, this.world.centerY, 'left1');
            this.left.anchor.setTo(0, 0.5);
            this.left.width = this.world.width / 2;
            this.left.scale.y = this.left.scale.x;
            this.right = this.add.sprite(this.world.width, this.world.centerY, 'right1');
            this.right.anchor.setTo(1, 0.5);
            this.right.width = this.world.width / 2;
            this.right.scale.y = this.right.scale.x;
            // Configure hotspot helpers:
            FryChallenge.Oil.Configure(this.world, this.right);
            FryChallenge.Fries.Configure(this.left);
            FryChallenge.Nuggets.Configure(this.left);
            FryChallenge.Handles.Configure(this.world, this.right);
            // Configure timer helper
            this.timers = new FryChallenge.Timers();
            // Create tool tray:
            this.toolTray = new FryChallenge.Controls.ToolTray();
            // Create quiz container:
            this.quiz = new FryChallenge.Controls.Quiz();
            // Start evaluating the scenario script:
            this.Evaluate();
        };
        Main.prototype.resize = function () {
            this.left.y = this.world.centerY;
            this.left.width = this.world.width / 2;
            this.left.scale.y = this.left.scale.x;
            this.right.y = this.world.centerY;
            this.right.x = this.world.width;
            this.right.width = this.world.width / 2;
            this.right.scale.y = this.right.scale.x;
            this.toolTray.Resize();
        };
        Main.prototype.EvaluateNext = function () {
            // Check if the last operation was scorable and add points based on the number of attempts.
            if (this.scoreArray.length > 0) {
                this.attempts = Math.min(this.attempts, this.scoreArray.length - 1);
                this.score += this.scoreArray[this.attempts];
                $('#scoreboard span').text(this.score);
                // TODO: Format the score number with commas.
                // Reset the score array so the next operation doesn't carry over the scoring:
                this.scoreArray = [];
            }
            this.currentOperation++;
            this.Evaluate();
        };
        Main.prototype.Evaluate = function (operation) {
            if (operation === void 0) { operation = null; }
            var op = operation || this.script[this.currentOperation];
            var self = this;
            if ('audioClip' in op) {
                this.PlayVoiceLine(op.audioClip);
            }
            // Clear any previous help timers
            clearInterval(this.helpTimer);
            // Dismiss any remaining helpers
            parent['tour'].cancel();
            window['tour'].cancel();
            // Perform the main operation
            this.Perform(op);
            this.scoreArray = op.score || [];
            this.attempts = 0;
            // If a tour helper exists for this operation, start the timer.
            if (!IsIniPhone()) {
                if (op.shellHelper) {
                    this.helpTimer = setTimeout(function () {
                        parent['tour'].show(op.shellHelper);
                    }, this.helpTime);
                }
                else if (op.helper) {
                    this.helpTimer = setTimeout(function () {
                        window['tour'].show(op.helper);
                    }, this.helpTime);
                }
            }
            // Optionally show a next button in the Shell header.
            if (op.showNext) {
                parent['$']('#instructions .hover-button').show();
                parent['$']('#instructions .hover-button').one('click', function () {
                    FryChallenge.FryGame.PlaySound('neutral');
                    $(this).hide();
                    self.EvaluateNext();
                });
            }
            else if (op.wait) {
                console.log('Waiting for user input.');
            }
            else {
                this.EvaluateNext();
            }
        };
        Main.prototype.Perform = function (op) {
            var self = this;
            switch (op.operation) {
                case 'instruct':
                    parent['$']('#instructions span').html(op.value);
                    break;
                case 'show-tools':
                    this.toolTray.Show(op.args, op.value, op.target, op.indicator);
                    break;
                case 'click-tool':
                    this.toolTray.ShowClick(op.args, op.value);
                    break;
                case 'hide-tools':
                    this.toolTray.Hide();
                    break;
                case 'increment-view':
                    this[op.args + 'Frame']++;
                    this[op.args].loadTexture(op.args + this[op.args + 'Frame'], 0);
                    break;
                case 'decrement-view':
                    this[op.args + 'Frame']--;
                    this[op.args].loadTexture(op.args + this[op.args + 'Frame'], 0);
                    break;
                case 'timer':
                    this.timers.Activate(op.target.zone, op.target.index || 0, op.args);
                    break;
                case 'reset-timer':
                    var auto = op.args ? op.args.auto || false : false;
                    this.timers.Reset(op.target.zone, op.target.index || 0, auto);
                    break;
                case 'carton':
                    $('#carton-' + op.value).animate({ top: 0 }, 500).one('click', function () {
                        $(this).animate({ top: -$(this).height() }, 500);
                        if (IsInMobileSafari())
                            $('#order-' + op.value)
                                .css({ left: self.world.centerX - $('#order-' + op.value).width() / 2 });
                        else
                            $('#order-' + op.value)
                                .css({ left: -$('#order-' + op.value).width() })
                                .animate({ left: self.world.centerX - $('#order-' + op.value).width() / 2 }, 500);
                        self.EvaluateNext();
                    });
                    break;
                case 'carton-on':
                    if (IsInMobileSafari())
                        $('#order-' + op.value)
                            .css({ left: self.world.centerX - $('#order-' + op.value).width() / 2 });
                    else
                        $('#order-' + op.value)
                            .css({ left: -$('#order-' + op.value).width() })
                            .animate({ left: self.world.centerX - $('#order-' + op.value).width() / 2 }, 500);
                    break;
                case 'carton-off':
                    if (IsInMobileSafari())
                        $('#order-' + op.value).hide();
                    else
                        $('#order-' + op.value).animate({ left: self.world.width + $('#order-' + op.value).width() }, 500);
                    break;
                case 'hotspot':
                    var callback_1 = function (e) {
                        var evt = e.type == "touchstart" ? e.originalEvent.touches[0] : e;
                        if (op.target.zone.Test(op.target.index, new Phaser.Point(evt.clientX, evt.clientY))) {
                            $('#container').off(FryChallenge.InputEvent.Click, callback_1);
                            FryChallenge.FryGame.PlaySound('good');
                            FryChallenge.FryGame.Correct();
                            // Show payoff animation or move on.
                            if (op.payoff) {
                                self.PlayAnimation(op.payoff);
                            }
                            else {
                                self.EvaluateNext();
                            }
                        }
                        else {
                            FryChallenge.FryGame.PlaySound('bad');
                            FryChallenge.FryGame.Wrong();
                            // Increment the number of attempts it took to get it right for scoring:
                            FryChallenge.FryGame.instance().state.getCurrentState().attempts++;
                        }
                    };
                    //-- Making hotspots visible
                    // let z = op.target.zone.Get(op.target.index);
                    // let g = this.game.add.graphics(0, 0);
                    // g.boundsPadding = 0;
                    // g.beginFill(0xff0000);
                    // g.drawRect(z.x, z.y, z.width, z.height)
                    // g.endFill();
                    $('#container').on(FryChallenge.InputEvent.Click, callback_1);
                    break;
                case 'dragspot':
                    // Create a new draggable image to display and add it to the document so it has a chance to load.
                    var clone_1 = document.createElement('img');
                    $(clone_1)
                        .attr('src', '../../Assets/Images/Game/' + op.args.image)
                        .css({
                        position: 'absolute',
                        zIndex: 10000,
                        display: 'none',
                        transform: 'scale(' + this.left.scale.x + ')'
                    }).appendTo(document.body);
                    var startCallback_1 = function (e) {
                        var evt = e;
                        if (e.type == 'touchstart')
                            evt = e.originalEvent.touches[0];
                        else if (e.type == 'MSPointerDown')
                            evt = e.originalEvent;
                        if (op.args.origin.zone.Test(op.args.origin.index, new Phaser.Point(evt.clientX, evt.clientY))) {
                            self.Perform(op.args.startOperation);
                            $('body').on(FryChallenge.InputEvent.MouseMove, moveCallback_1);
                            $('body').on(FryChallenge.InputEvent.MouseUp, dropCallback_1);
                            moveCallback_1(e);
                            $(clone_1).show();
                        }
                    };
                    var moveCallback_1 = function (e) {
                        var evt = e;
                        if (e.type == 'touchmove')
                            evt = e.originalEvent.touches[0];
                        else if (e.type == 'MSPointerMove')
                            evt = e.originalEvent;
                        // Keep the draggables inside the container because they cause iOS to inflate the iframe width when they go off the right or bottom.
                        var leftPosition = Math.min(evt.clientX - $(clone_1).width() / 2, $('body').width() - $(clone_1).width());
                        var topPosition = Math.min(evt.clientY - $(clone_1).height() / 2, $('body').height() - $(clone_1).height());
                        $(clone_1).css({
                            left: leftPosition,
                            top: topPosition
                        });
                        e.preventDefault();
                    };
                    var dropCallback_1 = function (e) {
                        var evt = e;
                        if (e.type == 'touchend')
                            evt = e.originalEvent.changedTouches[0];
                        else if (e.type == 'MSPointerUp')
                            evt = e.originalEvent;
                        $('body').off(FryChallenge.InputEvent.MouseMove, moveCallback_1);
                        $('body').off(FryChallenge.InputEvent.MouseUp, dropCallback_1);
                        $(clone_1).hide();
                        if (op.target.zone.Test(op.target.index, new Phaser.Point(evt.clientX, evt.clientY))) {
                            $('#container').off(FryChallenge.InputEvent.MouseDown, startCallback_1);
                            FryChallenge.FryGame.PlaySound('good');
                            FryChallenge.FryGame.Correct();
                            $(clone_1).remove();
                            self.EvaluateNext();
                        }
                        else {
                            FryChallenge.FryGame.PlaySound('bad');
                            FryChallenge.FryGame.Wrong();
                            self.Perform(op.args.wrongOperation);
                            // Increment the number of attempts it took to get it right for scoring:
                            FryChallenge.FryGame.instance().state.getCurrentState().attempts++;
                        }
                    };
                    $('#container').on(FryChallenge.InputEvent.MouseDown, startCallback_1);
                    break;
                case 'payoff':
                    // Important note, the first payoff should be behind a hotspot!
                    this.PlayAnimation(op.value);
                    break;
                case 'question':
                    this.quiz.Show(op.args);
                    $(document).off('touchmove');
                    break;
                case 'hide-quiz':
                    this.quiz.Hide();
                    $(document).on('touchmove', false);
                    break;
                case 'next-slide':
                    window['LMS'].SaveToSuspendData('slide' + window['Shell'].currentSlideNumber + 'Score', this.score);
                    if (Shell.IsSlideComplete(9)) {
                        Shell.GoToSlide(9);
                    }
                    else {
                        Slide.Complete();
                        window['Shell'].NextSlide();
                    }
                    break;
            }
        };
        Main.prototype.PlayAnimation = function (name) {
            var self = this;
            // Show the video container and fade it in.
            $('#video-container')
                .html('')
                .show()
                .animate({
                opacity: 1
            }, 500, function () {
                // Once the fade in is complete, show and play the video.
                $(this).html('<video autoplay controls webkit-playsinline playsinline onplaying="$(this).removeAttr(\'controls\');"><source src="../../Assets/Videos/' + name + '.mp4" type="video/mp4" /></video>');
                $(this).find('video').one('ended', function () {
                    // After the video, fade out the container and then move on.
                    $('#video-container').animate({ opacity: 0 }, 500, function () {
                        $(this).hide();
                        self.EvaluateNext();
                    });
                });
            });
        };
        Main.prototype.PlayVoiceLine = function (audioClip) {
            if ((IsInMobileSafari() || IsInAndroid()) && this.firstAudio) {
                this.firstAudio = false;
                return;
            }
            // Stop any previous audio so voice lines don't overlap
            if (this.voiceAudioId) {
                FryChallenge.FryGame.StopSound(this.voiceAudioName, this.voiceAudioId);
            }
            this.voiceAudioName = audioClip;
            this.voiceAudioId = FryChallenge.FryGame.PlaySound(audioClip);
        };
        return Main;
    }(Phaser.State));
    FryChallenge.Main = Main;
})(FryChallenge || (FryChallenge = {}));

///<reference path="../../../_Published/Source/XM/Events/XMEvent.js" />
///<reference path="../../../_Published/Source/XM/Slides/CustomSlide.js" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var FryChallenge;
(function (FryChallenge) {
    var Preload = (function (_super) {
        __extends(Preload, _super);
        function Preload() {
            _super.apply(this, arguments);
        }
        Preload.prototype.preload = function () {
            for (var key in window['manifest']) {
                this.load.image(key, window['manifest'][key]);
            }
        };
        Preload.prototype.create = function () {
            this.game.state.start('Main', true, false);
            Slide.Dispatch(XMEvent.Loaded);
        };
        return Preload;
    }(Phaser.State));
    FryChallenge.Preload = Preload;
})(FryChallenge || (FryChallenge = {}));

//# sourceMappingURL=FryChallenge.min.js.map
